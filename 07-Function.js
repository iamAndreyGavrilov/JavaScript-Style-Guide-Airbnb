// 7.1 Используйте функциональные выражения вместо объявлений функций.

// Почему? У объявлений функций есть подъём. Это означает, что можно использовать функцию до того, как она
// определена в файле, но это вредит читабельности и поддержке. Если вы обнаружили, что определение функции
// настолько большое или сложное, что мешает понимать остальную часть файла, то, возможно, пришло время извлечь
// его в отдельный модуль. Не забудьте явно назвать функциональное выражение, независимо от того, подразумевается
// ли имя из содержащейся переменной (такое часто бывает в современных браузерах или при использовании компиляторов,
// таких как Babel). Это помогает точнее определять место ошибки по стеку вызовов.

// плохо
function foo() {
    // ...
}

// плохо
const foo = function () {
    // ...
};

// хорошо
// лексическое имя, отличное от вызываемой(-ых) переменной(-ых)
const foo = function uniqueMoreDescriptiveLexicalFoo() {
    // ...
};

// 7.3 Никогда не объявляйте функции в нефункциональном блоке (if, while, и т.д.). Вместо этого присвойте функцию
// переменной. Браузеры позволяют выполнить ваш код, но все они интерпретируют его по-разному.

// 7.4 Примечание: ECMA-262 определяет блок как список инструкций. Объявление функции не является инструкцией.

// плохо
if (currentUser) {
    function test() {
        console.log('Nope.');
    }
}

// хорошо
let test;
if (currentUser) {
    test = () => {
        console.log('Yup.');
    };
}

// 7.5 Никогда не называйте параметр arguments. Он будет иметь приоритет над объектом arguments, который доступен для каждой функции.

// плохо
function foo(name, options, arguments) {
    // ...
}

// хорошо
function foo(name, options, args) {
    // ...
}

// 7.6 Никогда не используйте arguments, вместо этого используйте синтаксис оставшихся параметров ....
// плохо
function concatenateAll() {
    const args = Array.prototype.slice.call(arguments);
    return args.join('');
}

// хорошо
function concatenateAll(...args) {
    return args.join('');
}

// 7.7 Используйте синтаксис записи аргументов по умолчанию, а не изменяйте аргументы функции.

// очень плохо
function handleThings(opts) {
    // Нет! Мы не должны изменять аргументы функции.
    // Плохо вдвойне: если переменная opts будет ложной,
    // то ей присвоится пустой объект, а не то что вы хотели.
    // Это приведёт к коварным ошибкам.
    opts = opts || {};
    // ...
}

// всё ещё плохо
function handleThings(opts) {
    if (opts === void 0) {
        opts = {};
    }
    // ...
}

// хорошо
function handleThings(opts = {}) {
    // ...
}

// 7.8 Избегайте побочных эффектов с параметрами по умолчанию.

var b = 1;
// плохо
function count(a = b++) {
    console.log(a);
}
count();  // 1
count();  // 2
count(3); // 3
count();  // 3

// 7.9 Всегда вставляйте последними параметры по умолчанию.
// плохо
function handleThings(opts = {}, name) {
    // ...
}

// хорошо
function handleThings(name, opts = {}) {
    // ...
}

// 7.12 Никогда не изменяйте параметры
// Почему? Манипуляция объектами, приходящими в качестве параметров, может вызывать нежелательные
// побочные эффекты в вызывающей функции.

// плохо
function f1(obj) {
    obj.key = 1;
}

// хорошо
function f2(obj) {
    const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1;
}

// 7.13 Никогда не переназначайте параметры.
// плохо
function f1(a) {
    a = 1;
    // ...
}

function f2(a) {
    if (!a) { a = 1; }
    // ...
}

// хорошо
function f3(a) {
    const b = a || 1;
    // ...
}

function f4(a = 1) {
    // ...
}

// 7.14 Отдавайте предпочтение использованию синтаксис расширения ... при вызове вариативной функции.
// плохо
const x = [1, 2, 3, 4, 5];
console.log.apply(console, x);

// хорошо
const x = [1, 2, 3, 4, 5];
console.log(...x);

// плохо
new (Function.prototype.bind.apply(Date, [null, 2016, 8, 5]));

// хорошо
new Date(...[2016, 8, 5]);